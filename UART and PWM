

The HMI 
	The Nextion 322K024 HMI display is integrated into the setup to provide basic information display and collect user input for system configuration. Its critical functions include controlling the start and stop operations of the conveyor belt used to transport boxes for scanning, and presenting the model's inference result (classifying the box as defective or non-defective). Communication between the HMI and the ICICLE KIT is established via UART. The implementation utilizes the last freely available MSS HardUART, designated as MMUART4, which is physically routed to the MikroBus header pins on the board for connection.

Basic code for the UART protocol connecting the Nextion via the tty terminal interface. 

	The serial UART terminal is first configured. 
	
int configure_serial(int fd, int baud)
{
    struct termios tty;
    if (tcgetattr(fd, &tty) != 0) {
        perror("tcgetattr");
        return -1;
    }


    tty.c_iflag &= ~(IGNBRK | BRKINT | ICRNL | INLCR | PARMRK | ISTRIP | IXON | IXOFF | IXANY);
    tty.c_oflag &= ~OPOST;
    tty.c_cflag &= ~(CSIZE | PARENB | CSTOPB | CRTSCTS);
    tty.c_cflag |= CS8 | CREAD | CLOCAL;
    tty.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    tty.c_cc[VMIN] = 1;    
    tty.c_cc[VTIME] = 0;   

    speed_t speed;
    switch (baud) {
        case 9600: speed = B9600; break;
        case 19200: speed = B19200; break;
        case 38400: speed = B38400; break;
        case 115200: speed = B115200; break;
        default:
            fprintf(stderr, "Unsupported baud %d, using 9600\n", baud);
            speed = B9600;
    }

    cfsetispeed(&tty, speed);
    cfsetospeed(&tty, speed);

    if (tcsetattr(fd, TCSANOW, &tty) != 0) {
        perror("tcsetattr");
        return -1;
    }

    
    tcflush(fd, TCIOFLUSH);
    return 0;
}

The below snippet then listens via the tty interface, captures the symbol being parsed by the Nextion and then prints that onto the terminal interface. 	

 while (keep_running) {
        n = read(fd, buf, sizeof(buf));
        if (n < 0) {
            if (errno == EINTR) continue;
            perror("read");
            break;
        } else if (n == 0) {
            // no data
            continue;
        }

        for (ssize_t i = 0; i < n; ++i) {
            unsigned char c = buf[i];
            if (isprint(c) || c == '\n' || c == '\r' || c == '\t') {
                putchar(c);
                fflush(stdout);
            } else {
                // print hex for non-printables
                printf("[0x%02X]", c);
                fflush(stdout);
            }
        }
    }



The PWM 
	The Pulse Width Modulation (PWM) signal is employed to supply regulated control inputs to the motor driver, which in turn manages the motors within the system. This PWM signal is generated by a CoreUART module instantiated within the FPGA fabric. Like the HMI interface, this signal is physically routed to the MikroBus header pins.

System-level access to the PWM core is facilitated through the Linux environment because the system image includes a Device Tree Source (DTS) node for the PWM core in the fabric. This allows the core to be controlled via the Linux virtual filesystem at the path /sys/class/pwm/pwmchip0. The control program exports a specific PWM channel, configures critical parameters such as the duty cycle, period, and frequency, and subsequently enables the PWM output. This entire operation is handled by the C program using standard file I/O operations.




