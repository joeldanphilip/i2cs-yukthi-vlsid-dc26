

The HMI 
	The Nextion 322K024 HMI display is integrated into the setup to provide basic information display and collect user input for system configuration. Its critical functions include controlling the start and stop operations of the conveyor belt used to transport boxes for scanning, and presenting the model's inference result (classifying the box as defective or non-defective). Communication between the HMI and the ICICLE KIT is established via UART. The implementation utilizes the last freely available MSS HardUART, designated as MMUART4, which is physically routed to the MikroBus header pins on the board for connection.

Basic code for the UART protocol connecting the Nextion via the tty terminal interface. 

	The serial UART terminal is first configured. 
	
int configure_serial(int fd, int baud)
{
    struct termios tty;
    if (tcgetattr(fd, &tty) != 0) {
        perror("tcgetattr");
        return -1;
    }


    tty.c_iflag &= ~(IGNBRK | BRKINT | ICRNL | INLCR | PARMRK | ISTRIP | IXON | IXOFF | IXANY);
    tty.c_oflag &= ~OPOST;
    tty.c_cflag &= ~(CSIZE | PARENB | CSTOPB | CRTSCTS);
    tty.c_cflag |= CS8 | CREAD | CLOCAL;
    tty.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    tty.c_cc[VMIN] = 1;    
    tty.c_cc[VTIME] = 0;   

    speed_t speed;
    switch (baud) {
        case 9600: speed = B9600; break;
        case 19200: speed = B19200; break;
        case 38400: speed = B38400; break;
        case 115200: speed = B115200; break;
        default:
            fprintf(stderr, "Unsupported baud %d, using 9600\n", baud);
            speed = B9600;
    }

    cfsetispeed(&tty, speed);
    cfsetospeed(&tty, speed);

    if (tcsetattr(fd, TCSANOW, &tty) != 0) {
        perror("tcsetattr");
        return -1;
    }

    
    tcflush(fd, TCIOFLUSH);
    return 0;
}

The below snippet then listens via the tty interface, captures the symbol being parsed by the Nextion and then prints that onto the terminal interface. 	

 while (keep_running) {
        n = read(fd, buf, sizeof(buf));
        if (n < 0) {
            if (errno == EINTR) continue;
            perror("read");
            break;
        } else if (n == 0) {
            // no data
            continue;
        }

        for (ssize_t i = 0; i < n; ++i) {
            unsigned char c = buf[i];
            if (isprint(c) || c == '\n' || c == '\r' || c == '\t') {
                putchar(c);
                fflush(stdout);
            } else {
                // print hex for non-printables
                printf("[0x%02X]", c);
                fflush(stdout);
            }
        }
    }



The PWM 
	The Pulse Width Modulation (PWM) signal is employed to supply regulated control inputs to the motor driver, which in turn manages the motors within the system. This PWM signal is generated by a CoreUART module instantiated within the FPGA fabric. Like the HMI interface, this signal is physically routed to the MikroBus header pins.

System-level access to the PWM core is facilitated through the Linux environment because the system image includes a Device Tree Source (DTS) node for the PWM core in the fabric. This allows the core to be controlled via the Linux virtual filesystem at the path /sys/class/pwm/pwmchip0. The control program exports a specific PWM channel, configures critical parameters such as the duty cycle, period, and frequency, and subsequently enables the PWM output. This entire operation is handled by the C program using standard file I/O operations.


int pwm_setup(int channel, int period_ns, int duty_ns) {
    char path[256];
    char buffer[50];
    int fd;


Sets the parameters for opening the device file. 

    snprintf(path, sizeof(path), "%s/pwm%d/period", PWM_CHIP_PATH, channel);
    if (access(path, F_OK) != 0) {
        snprintf(path, sizeof(path), "%s/export", PWM_CHIP_PATH);
        fd = open(path, O_WRONLY);
        if (fd < 0) { perror("Failed to open export"); return -1; }
        snprintf(buffer, sizeof(buffer), "%d", channel);
        write(fd, buffer, strlen(buffer));
        close(fd);
    }

This opens the device file and sets the period, the duty cycle and then enables the pwm in the channel export that is created. 

    snprintf(path, sizeof(path), "%s/pwm%d/period", PWM_CHIP_PATH, channel);
    fd = open(path, O_WRONLY);
    if (fd < 0) { perror("Failed to open period"); return -1; }
    snprintf(buffer, sizeof(buffer), "%d", period_ns);
    write(fd, buffer, strlen(buffer));
    close(fd);

    snprintf(path, sizeof(path), "%s/pwm%d/duty_cycle", PWM_CHIP_PATH, channel);
    fd = open(path, O_WRONLY);
    if (fd < 0) { perror("Failed to open duty_cycle"); return -1; }
    snprintf(buffer, sizeof(buffer), "%d", duty_ns);
    write(fd, buffer, strlen(buffer));
    close(fd);

    snprintf(path, sizeof(path), "%s/pwm%d/enable", PWM_CHIP_PATH, channel);
    fd = open(path, O_WRONLY);
    if (fd < 0) { perror("Failed to open enable"); return -1; }
    write(fd, "1", 1);
    close(fd);

    return 0;
}



High Level Overview of the System. 

Our propsed work is a post packaging defect detection prototype that is powered by the Microchip PolarFire Icicle SoC. We make use a CNN based model for the defect detection and most importantly the VectorBlox flow in the Icicle Kit for converting our IP to a Soft Core in the FPGA fabric where the computations are performed. Our CNN model is based on the ___ architecture and was trained on a custom dataset that we curated ourselves. 

